`alert`가 전달받은 값의 자료형과 관계없이 이를 문자열로 자동 변환하여 보여주는 것이나, 수학 관련 연산자가 전달받은 값을 숫자로 변환하는 경우가 형 변환의 대표적인 예시입니다.

# 문자형으로 변환

```jsx
let value = true;
alert(typeof value); // boolean

value = String(value); // 변수 value엔 문자열 "true"가 저장됩니다.
alert(typeof value); // string
```

# 숫자형으로 변환

```jsx
let str = "123";
alert(typeof str); // string

let num = Number(str); // 문자열 "123"이 숫자 123으로 변환됩니다.

alert(typeof num); // number
```

# 불린형으로의 변환

문자열일 경우 값이 존재하면 “ “ 만 아니면 true

```jsx
Boolean(1)
Boolean(0) > False
Boolean('') > False
Boolean('0' > True
```

# 특이한 + 연결

자바스크립트의 특이한 기능을 알아보자

```jsx
let s = "my" + "string";
alert(s); // mystring

//여기서는 문자열이 갑..

```

따라서 이항 연산자 `+`를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다는 점에 주의해야 합니다.

# 이항 연산자로써의 +

두개를 더해서 하나의 새로운 타입에 넣으면

둘중 뭐가 됐든 문자열임

```jsx
lert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
alert(2+2+'1') // "41"
```

연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 이런 결과가 나왔습니다. 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열과의 병합이 일어납니다.

이처럼 이항 덧셈 연산자 `+`는 문자열 연결과 변환이라는 특별한 기능을 제공합니다. 다른 산술 연산자가 오직 숫자형의 피연산자만 다루고, 피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾸는 것과는 대조적입니다.

# 이항 연산자 + 의 문자열 연결

는 특이함

하지만..

**그렇다면 + 만 문자열과 만날때 상당히 특이하게 concat하는 습관이 있는거네?**

**답변**

**네, 맞습니다! JavaScript에서 `+` 연산자는 다른 프로그래밍 언어와 달리 문자열과 만나면 문자열을 연결(concatenate)하는 특성이 있습니다. 이는 `+` 연산자가 숫자뿐만 아니라 문자열에 대해서도 사용될 수 있기 때문입니다.**

**즉, `+` 연산자는 다음과 같은 방식으로 작동합니다:**

**두 개의 피연산자가 모두 숫자일 경우, 숫자 덧셈을 수행합니다.하나의 피연산자가 문자열일 경우, 다른 피연산자를 문자열로 변환한 후 두 문자열을 연결합니다.**

### 나머지는요

**JavaScript에서 `-`, `/`, `*` 이항 연산자는 숫자 연산에 사용되며, 문자열과 만나면 문자열을 숫자로 변환하려고 시도합니다.**

즉, 정리하자면 빼기 나누기 곱하기는 문자열이어도, 만약 숫자형태라면 자동적으로 수식 계산을 해주지만

더하기는 가차없다.

- **`` (빼기): 두 피연산자가 모두 숫자여야 하며, 만약 문자열이 포함되어 있으면, 해당 문자열이 숫자로 변환될 수 있다면 변환 후 연산을 수행합니다. 만약 변환이 불가능하면 `NaN`을 반환합니다.**
    - **`` (곱하기): 이 연산자도 마찬가지로 문자열이 숫자로 변환될 수 있으면 변환 후 곱셈을 수행합니다. 변환이 불가능하면 `NaN`을 반환합니다.**
    - **`/` (나누기): 이 연산**

```jsx
console.log("5" - 2);// 3
console.log("5" * 2);// 10
console.log("10" / 2);// 5
console.log("hello" - 2);// NaN
```

# 단항 연산자 +

# 먼저 숫자로써의 단항연산자

는 영향이 없음 ㅋ

# 하지만 문자와의 단항연산자

는 좀 다름

```jsx
/ 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
alert( +true ); // 1
alert( +"" );   // 0
```

+문자  라는 이 놈은

Number(문자 ) 와 동일한 일을함..

# 이게 이렇게 굳이 헷갈리게 해야하나요

개발을 하다보면 문자열을 숫자로 변환해야하는 경우가 많다.

```jsx
let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert( +apples + +oranges ); // 5

// `Number(...)`를 사용해서 같은 동작을 하는 코드를 작성할 수 있지만, 더 기네요.
// alert( Number(apples) + Number(oranges) ); // 5

따라서 이런식으로..
+는 Number()와 비슷한 성격을 지닌다 when with 문자열
```

# 연산자의 우선순위

![스크린샷 2024-09-06 오후 7.59.23.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/729e57e5-b076-4aed-8063-2a5691ec5597/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.59.23.png)

할당이 젤 약하다. 따라서 거의 마지막에 실행된다고 봐도 무방함

참고로

'단항 덧셈 연산자’는 우선순위 `17`로, '(이항) 덧셈 연산자’의 우선순위 `13`보다 높습니다. 표현식 `"+apples + +oranges"`에서 단항 덧셈 연산자가 덧셈보다 먼저 수행되는 이유가 바로 이 때문입니다.

```jsx
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

# 복합 할당 연산자

```jsx
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (*=의 우측이 먼저 평가되므로, 위 식은 n *= 8과 동일합니다.)
```

# 증가 감소 연산자

++,  - - 이런건데

이건 변수에만 쓰자.

하지만 우선순위가 상당히 큼

# 전위형 과 후위형

num++ or ++num 이 차이인데

### 먼저 값을 올리고 값을 반환한다 와 반환하고 값을 올린다 차이임

# 우선순위가 크다는데요

위를 참고해서 먼저 값 올리고 할당할건지 아닌지 정하면 될것같네요 그니까 

# 문제

![스크린샷 2024-09-06 오후 8.32.42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/73415720-3784-4ed7-990e-8b1c51c12164/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.32.42.png)

1. 피 연산자 중 하나가 문자열인 `"" + 1`에서 `1`은 문자형으로 변환됩니다. 따라서 공백과 문자열 1을 더한, `"" + 1 = "1"`과 같은 효과를 발휘하죠. 그다음 연산 `"1" + 0`에도 같은 규칙이 적용됩니다.
2. 뺄셈 연산자 ``는 기타 수학 연산자처럼 숫자형만을 인수로 받습니다. 빈 문자열 `""`는 숫자 `0`으로 변환되기 때문에 결과는 `1`이 됩니다.
3. 피 연산자 중 하나가 문자열이므로 숫자 5가 문자열로 변환됩니다.
4. 뺄셈 연산자는 인수를 숫자형으로 변화시키므로 `" -9 "`는 숫자 `9`로 변합니다. 앞, 뒤 공백은 제거되죠.
5. 숫자형으로 변환 시 `null`은 `0`이 됩니다.
6. `undefined`는 숫자형으로 변환시 `NaN`이 됩니다.
7. 문자열이 숫자형으로 변할 땐 문자열 앞뒤의 공백이 삭제됩니다. 뺄셈 연산자 앞의 피연산자는 공백을 만드는 문자 `\t`와 `\n`, 그 사이의 “일반적인” 공백으로 구성됩니다. 따라서 `" \t \n"`는 숫자형으로 변환 시 길이가 `0`인 문자열로 취급되어 숫자 `0`이 됩니다.

![스크린샷 2024-09-06 오후 8.37.38.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/c461b154-8c71-4c11-a49d-a6d8a0ef8731/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.37.38.png)

+는 매우 중요하고 유용한 놈이겠다

문자열 concating

Number로 type casting 깔즤 ㅋㅋ;
